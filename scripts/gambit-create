#!/usr/bin/env python3

import argparse
import uuid

parser = argparse.ArgumentParser(
    description = 'Generate a Gambit database. Requires preprocessed input files',
    usage = 'gambitdb_create [options]',
    formatter_class=argparse.ArgumentDefaultsHelpFormatter)
# Required input files
parser.add_argument('genome_assembly_metadata',  help='A CSV containing the assembly file and path, and the species taxon ID', type=str)
parser.add_argument('species_taxon_filename', help='A CSV containing species taxonomy', type=str)
parser.add_argument('signatures_filename', help='A signatures .h5 file created by gambit signatures', type=str)

# optional input values
parser.add_argument('--db_key',  help='Unique key for database, no spaces', default = 'organisation/database', type=str)
parser.add_argument('--db_version',  help='Unique version, x.y.z', default = '1.0.0', type=str)
parser.add_argument('--db_author',  help='Name of person who created the database', default = 'Jane Doe', type=str)
parser.add_argument('--db_date',  help='Date database was created as YYYY-MM-DD', default = '2022-12-31', type=str)

# Optional output file names that you probably want to leave as defaults
parser.add_argument('--signatures_output_filename', '-s', help='Output filename for genome signatures', default = 'database.gs', type=str)
parser.add_argument('--database_output_filename', '-g', help='Output filename for core database', default = 'database.gdb', type=str)
parser.add_argument('--verbose', '-v', action='store_true', help='Turn on verbose output', default = False)
options = parser.parse_args()

###### species_taxon_filename
#species_taxid,name,rank,parent_taxid,ncbi_taxid,gambit_taxid
#10,Yellow black,species,1,10,10
#11,Red white,species,1,11,11

###### genome_assembly_metadata
#uuid,assembly_filename,species_taxid,assembly_accession
#1,gambitdb/tests/data/test_dataset/sample1.fa,10,sample1
#2,gambitdb/tests/data/test_dataset/sample1_1.fa,10,sample1_1

#############
#
#############

# These scripts were adapted from code provided 
# by Jared Lumpe which demonstrated the approach for GAMBIT db curation

import pandas as pd
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
# AGPL-3.0
from gambit.db import ReferenceGenomeSet, Genome, AnnotatedGenome, Taxon
from gambit.db.migrate import init_db
from gambit.sigs import SignaturesMeta, load_signatures, dump_signatures, AnnotatedSignatures


# load data and set the types
genomes_df = pd.read_csv(options.genome_assembly_metadata, dtype=str)
genomes_df['species_taxid'] = genomes_df['species_taxid'].fillna(0).astype(int)
genomes_df = genomes_df.fillna('')
taxa_df = pd.read_csv(options.species_taxon_filename, dtype=str)
taxa_df['species_taxid'] = taxa_df['species_taxid'].fillna(0).astype(int)
taxa_df['parent_taxid'] = taxa_df['parent_taxid'].fillna(0).astype(int)
taxa_df['ncbi_taxid'] = taxa_df['ncbi_taxid'].fillna(0).astype(int)
taxa_df['gambit_taxid'] = taxa_df['gambit_taxid'].fillna(0).astype(int)
taxa_df['report'] = taxa_df['report'].fillna(0).astype(int)
taxa_df['diameter'] = taxa_df['diameter'].fillna(0.0).astype(float)
taxa_df['ngenomes'] = taxa_df['ngenomes'].fillna(0).astype(int)
taxa_df = taxa_df.fillna('')


# Create databawse
engine = create_engine('sqlite:///' + options.database_output_filename, echo=options.verbose)
init_db(engine)
Session = sessionmaker(engine)
session = Session()

# ### Genome set
# 
# `ReferenceGenomeSet` basically encompasses the concept of a "gambit database," but because it is just a row in a table you can technically have more than one. The CLI commands expect there to be just one per SQLite file, though.
gset = ReferenceGenomeSet(
    key=options.db_key,
    version=options.db_version,
    name=str(options.db_key)+ ' version '+ str(options.db_version) +' database',
    description=str(options.db_key)+ ' version '+ str(options.db_version) +' database',
    # This is arbitrary JSON data. There's no set schema for it currently.
    extra=dict(
        author=options.db_author,
        date=options.db_date,
    ),
)
session.add(gset)
session.commit()

# At this point the taxon 'id' hasnt been set, but we will assume they are inserted in order (+1)
taxon_ids = taxa_df[taxa_df['species_taxid'] != taxa_df['parent_taxid'] ]['species_taxid'].tolist()
taxon_index = dict()
for i in range(len(taxon_ids)):
    # add 1 because the sql rows start from 1 not 0
    taxon_index[taxon_ids[i]] = i + 1

#### Taxa
taxa = dict()

for row in taxa_df.itertuples():
    parent_taxa_db_id = ""
    if row.parent_taxid != 1 and row.parent_taxid in taxon_index:
        parent_taxa_db_id = taxon_index[row.parent_taxid]

    taxon = Taxon(
        key=str(uuid.uuid4()),
        name=row.name,
        rank=row.rank,
        description='',
        distance_threshold=row.diameter,
        # if 1, GAMBIT will assign samples to this taxa, set subspecies to 0
        report=(0 if row.report == "" or row.report == 0 else 1), 
        genome_set=gset,
        parent_id=parent_taxa_db_id, 
        ncbi_id=row.ncbi_taxid,
    )
    taxa[row.name] = taxon
    session.add(taxon)
    
session.commit()




# ### Genomes
for row in genomes_df.itertuples():
    taxon = taxa[row.species]
    
    genome = Genome(
        key=row.assembly_accession,
        description=f'[{row.assembly_accession}] {row.species}',
        ncbi_db='assembly',
        ncbi_id=row.uuid,
        genbank_acc=row.assembly_accession,
    )
    session.add(genome)
    
    ag = AnnotatedGenome(
        genome=genome,
        genome_set=gset,
        taxon=taxon,
        organism=taxon.name,
    )
    session.add(ag)
    
session.commit()

# ### Signatures

meta = SignaturesMeta(
    id=options.db_key,
    version=options.db_version,
    name=str(options.db_key)+ ' version '+ str(options.db_version) +' database',
    description=str(options.db_key)+ ' version '+ str(options.db_version) +' database',
    id_attr='genbank_acc',
)

with load_signatures(options.signatures_filename) as src:
    out_sigs = AnnotatedSignatures(src, src.ids, meta)
    dump_signatures(options.signatures_output_filename, out_sigs)
