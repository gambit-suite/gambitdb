import pandas as pd
import logging
import sys
import os

# This class takes the output of gambitdb-gtdb and allows for corrections to species
# names according to NCBI taxonomy before the database is created

class GtdbSpeciesCorrector:
    """
    Corrects species classifications from GTDB to match NCBI taxonomy for specified taxa.
    This is meant to be run after gambitdb-gtdb but before database creation.
    """
    def __init__(self, 
                 gtdb_metadata_spreadsheet,
                 assembly_metadata_file,
                 species_taxa_file,
                 genus_file=None,
                 output_assembly_metadata_file=None,
                 output_species_taxa_file=None,
                 collapse_genera=True,
                 debug=False, 
                 verbose=False):
        """
        Initializes the GtdbSpeciesCorrector class.
        Args:
            gtdb_metadata_spreadsheet (str): Path to the original GTDB metadata spreadsheet
            assembly_metadata_file (str): Path to the assembly_metadata.csv file generated by gambitdb-gtdb
            species_taxa_file (str): Path to the species_taxa.csv file generated by gambitdb-gtdb
            genus_file (str): Path to a file containing a list of genera to correct (1 per line)
            collapse_genera (bool): Whether to collapse novel genera with '_X' suffix to their parent genus
            output_assembly_metadata_file (str): Path to write corrected assembly metadata (default: {input}_corrected.csv)
            output_species_taxa_file (str): Path to write corrected species taxa (default: {input}_corrected.csv)
            debug (bool): Whether to enable debugging mode
            verbose (bool): Whether to enable verbose mode
        """
        self.gtdb_metadata_spreadsheet = gtdb_metadata_spreadsheet
        self.assembly_metadata_file = assembly_metadata_file
        self.species_taxa_file = species_taxa_file
        self.genus_file = genus_file
        self.species_to_correct = []
        self.collapse_genera = collapse_genera
        
        # We can just set the output files to be the same as the input files with "_corrected" added
        self.output_assembly_metadata_file = output_assembly_metadata_file or self._get_corrected_filename(assembly_metadata_file)
        self.output_species_taxa_file = output_species_taxa_file or self._get_corrected_filename(species_taxa_file)
        
        self.debug = debug
        self.verbose = verbose
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.INFO)
        self.logger.addHandler(logging.StreamHandler(sys.stdout))
        if self.debug:
            self.logger.setLevel(logging.DEBUG)
        if self.verbose:
            self.logger.setLevel(logging.INFO)

        self.stats_total_assemblies = 0
        self.stats_corrected_assemblies = 0
        self.stats_total_species = 0
        self.stats_corrected_species = 0
        
        if self.genus_file and os.path.exists(self.genus_file):
            self._process_genus_file()

    def _get_corrected_filename(self, filename):
        """
        Generate a corrected filename by inserting '_corrected' before the extension.
        """
        base, ext = os.path.splitext(filename)
        return f"{base}_corrected{ext}"
    
    def _process_genus_file(self):
        """
        Process the genus file and add formatted genus prefixes to species_to_correct.
        The genus file should contain one genus name per line (e.g., "Shigella").
        This method formats the genus names to the GTDB taxonomy pattern "g__Genus;s__".
        """
        self.logger.info(f"Processing genus file: {self.genus_file}")
        try:
            with open(self.genus_file, 'r') as f:
                for line in f:
                    genus = line.strip()
                    if not genus or genus.startswith('#'):
                        continue
                    # Format the genus name according to GTDB taxonomy pattern, or at least what's in the GTDB metadata file
                    formatted_genus = f"g__{genus};s__"
                    self.species_to_correct.append(formatted_genus)
                    self.logger.debug(f"Added genus to correct: {genus} -> {formatted_genus}")
            
            self.logger.info(f"Loaded {len(self.species_to_correct)} genera to correct from file")
        except Exception as e:
            self.logger.error(f"Error processing genus file: {str(e)}")
            raise

    def read_files(self):
        """
        Read the input files into dataframes.
        """
        self.logger.info("Reading input files")
        # Read original GTDB metadata
        self.original_gtdb_df = pd.read_csv(self.gtdb_metadata_spreadsheet, sep='\t', index_col=False)
        self.original_gtdb_df = self.original_gtdb_df.fillna('')
        
        # Remove prefixes from accessions -- GTDB specific tags
        self.original_gtdb_df['accession'] = self.original_gtdb_df['accession'].str.replace('GB_', '')
        self.original_gtdb_df['accession'] = self.original_gtdb_df['accession'].str.replace('RS_', '')
        
        # Create a species column if it doesn't exist
        if 'species' not in self.original_gtdb_df.columns:
            self.original_gtdb_df['species'] = self.original_gtdb_df['gtdb_taxonomy'].str.extract(r's__([a-zA-Z0-9_\-\s]+)', expand=False)
        
        # Read assembly metadata file
        self.assembly_metadata_df = pd.read_csv(self.assembly_metadata_file)
        self.stats_total_assemblies = len(self.assembly_metadata_df)
        
        # Read species taxa file
        self.species_taxa_df = pd.read_csv(self.species_taxa_file)
        self.stats_total_species = len(self.species_taxa_df)
        
        self.logger.info(f"Read {self.stats_total_assemblies} assemblies and {self.stats_total_species} species")

    def correct_species(self):
        """
        Correct the species classifications based on NCBI taxonomy.
        Only makes corrections for genera specified in the genus file.
        Accessions remain unchanged - only the species names and taxids are updated.
        Preserves specific species within a genus (e.g., different Shigella species).
        """
        self.logger.info("Correcting species classifications")
        
        if not self.species_to_correct:
            self.logger.info("No genera specified for correction. Skipping species correction step.")
            return
            
        # Create a mapping from accession to NCBI species name
        accession_to_ncbi_species = {}
        
        # Process each genus prefix to correct
        for genus_prefix in self.species_to_correct:
            self.logger.info(f"Processing corrections for {genus_prefix}")
            
            # Filter the GTDB metadata for genomes with this genus prefix in ncbi_taxonomy
            filtered_df = self.original_gtdb_df[self.original_gtdb_df['ncbi_taxonomy'].str.contains(genus_prefix, na=False)]
            
            # Skip if no genomes found
            if len(filtered_df) == 0:
                self.logger.warning(f"No genomes found with {genus_prefix} in NCBI taxonomy")
                continue
            
            # For each genome, create a mapping from accession to NCBI species
            for _, row in filtered_df.iterrows():
                accession = row['accession']
                ncbi_species = row['ncbi_taxonomy'].split('s__')[-1].strip() if 's__' in row['ncbi_taxonomy'] else None
                
                # Skip if no valid NCBI species found
                if not ncbi_species:
                    self.logger.debug(f"No valid NCBI species found for {accession}")
                    continue
                
                # Store the NCBI species for this accession
                accession_to_ncbi_species[accession] = ncbi_species
        
        # Log the number of accessions we found
        self.logger.info(f"Found {len(accession_to_ncbi_species)} accessions with genera that need correction")
        
        # Create a mapping to lookup species_taxid by species name
        species_to_taxid = dict(zip(self.species_taxa_df['name'], self.species_taxa_df['species_taxid']))
        
        # Map to keep track of which accessions are assigned to which species
        species_accessions = {}
        original_species = {}
        
        # First, collect all the corrections we'll need to make
        for accession, ncbi_species in accession_to_ncbi_species.items():
            # Find this accession in the assembly metadata
            if accession in self.assembly_metadata_df['assembly_accession'].values:
                # Get the current GTDB species for this accession
                mask = self.assembly_metadata_df['assembly_accession'] == accession
                gtdb_species = self.assembly_metadata_df.loc[mask, 'species'].iloc[0]
                
                # Only correct if the GTDB species is different from the NCBI species
                if gtdb_species != ncbi_species:
                    # Keep track of which accessions belong to the original species
                    if gtdb_species not in original_species:
                        original_species[gtdb_species] = []
                    original_species[gtdb_species].append(accession)
                    
                    # Keep track of which accessions will be assigned to each new species
                    if ncbi_species not in species_accessions:
                        species_accessions[ncbi_species] = []
                    species_accessions[ncbi_species].append(accession)
        
        # Create any new species entries needed
        for ncbi_species, accessions in species_accessions.items():
            if ncbi_species not in species_to_taxid:
                # Get the gtdb species and taxid for the first accession (as a template)
                first_acc = accessions[0]
                mask = self.assembly_metadata_df['assembly_accession'] == first_acc
                gtdb_species = self.assembly_metadata_df.loc[mask, 'species'].iloc[0]
                gtdb_taxid = self.assembly_metadata_df.loc[mask, 'species_taxid'].iloc[0]
                
                # Generate a new taxid
                max_taxid = self.species_taxa_df['species_taxid'].max()
                new_taxid = max_taxid + 1
                
                # Create a new entry based on the template of the original species
                template_row = self.species_taxa_df[self.species_taxa_df['species_taxid'] == gtdb_taxid].iloc[0].copy()
                new_row = pd.Series({
                    'species_taxid': new_taxid,
                    'name': ncbi_species,
                    'rank': 'species',
                    'parent_taxid': template_row['parent_taxid'],
                    'ncbi_taxid': template_row['ncbi_taxid'],
                    'gambit_taxid': template_row['gambit_taxid'],
                    'report': template_row['report'],
                    'ngenomes': len(accessions)
                })
                
                self.species_taxa_df = pd.concat([self.species_taxa_df, pd.DataFrame([new_row])], ignore_index=True)
                species_to_taxid[ncbi_species] = new_taxid
                self.stats_corrected_species += 1
                
                self.logger.info(f"Created new species entry: {ncbi_species} (taxid: {new_taxid}) with {len(accessions)} genomes")
            else:
                # Update ngenomes for existing species
                taxid = species_to_taxid[ncbi_species]
                self.species_taxa_df.loc[self.species_taxa_df['species_taxid'] == taxid, 'ngenomes'] = len(accessions)
                self.logger.info(f"Updated existing species: {ncbi_species} (taxid: {taxid}) with {len(accessions)} genomes")
        
        # Update assembly metadata for each accession
        for ncbi_species, accessions in species_accessions.items():
            taxid = species_to_taxid[ncbi_species]
            for accession in accessions:
                mask = self.assembly_metadata_df['assembly_accession'] == accession
                self.assembly_metadata_df.loc[mask, 'species'] = ncbi_species
                self.assembly_metadata_df.loc[mask, 'species_taxid'] = taxid
                self.stats_corrected_assemblies += 1
        
        # Update ngenomes for original species that lost genomes
        for gtdb_species, accessions in original_species.items():
            if gtdb_species in species_to_taxid:
                taxid = species_to_taxid[gtdb_species]
                # Count how many genomes are still assigned to this species
                remaining_count = len(self.assembly_metadata_df[self.assembly_metadata_df['species'] == gtdb_species])
                self.species_taxa_df.loc[self.species_taxa_df['species_taxid'] == taxid, 'ngenomes'] = remaining_count
                self.logger.info(f"Updated original species: {gtdb_species} (taxid: {taxid}) with {remaining_count} remaining genomes")
        
        self.logger.info(f"Corrected {self.stats_corrected_assemblies} assemblies and {self.stats_corrected_species} species entries")
        
    def collapse_novel_genera(self):
        """
        Collapse novel genus names with '_X' suffix to their parent genus.
        For example, "Escherichia_A" would be collapsed to "Escherichia".
        """
        self.logger.info("Collapsing novel genera with '_X' suffix")
        
        self.stats_collapsed_genera = 0
        self.stats_collapsed_species = 0
        self.stats_collapsed_assemblies = 0
        
        # Extract genus information from species names
        self.species_taxa_df['genus'] = self.species_taxa_df['name'].str.split(' ').str[0]
        
        # Find all genera
        all_genera = set(self.species_taxa_df['genus'])
        
        # Identify novel genera with '_X' suffix
        novel_genera = {g for g in all_genera if '_' in g}
        if not novel_genera:
            self.logger.info("No novel genera with '_X' suffix found")
            # Remove the temporary genus column
            self.species_taxa_df.drop('genus', axis=1, inplace=True)
            return
        
        self.logger.info(f"Found {len(novel_genera)} novel genera to collapse")
        
        # Create a mapping from novel genus to parent genus
        genus_mapping = {}
        for novel_genus in novel_genera:
            # Get the parent genus (everything before the underscore)
            parent_genus = novel_genus.split('_')[0]
            if parent_genus in all_genera:
                genus_mapping[novel_genus] = parent_genus
                self.logger.debug(f"Mapping {novel_genus} to {parent_genus}")
        
        self.stats_collapsed_genera = len(genus_mapping)
        
        # Update species names for all species with novel genera
        for novel_genus, parent_genus in genus_mapping.items():
            # Find all species with this novel genus
            mask = self.species_taxa_df['genus'] == novel_genus
            if not mask.any():
                continue
                
            # Update the species names to use the parent genus
            for idx in self.species_taxa_df[mask].index:
                old_name = self.species_taxa_df.loc[idx, 'name']
                new_name = old_name.replace(novel_genus + ' ', parent_genus + ' ')
                self.species_taxa_df.loc[idx, 'name'] = new_name
                self.logger.debug(f"Updated species {old_name} to {new_name}")
                self.stats_collapsed_species += 1
        
        self.logger.info(f"Updated {self.stats_collapsed_species} species names to use parent genus")
        
        # Now update the assembly metadata to match the new species names
        for novel_genus, parent_genus in genus_mapping.items():
            for species in self.assembly_metadata_df['species'].unique():
                if species.startswith(novel_genus + ' '):
                    new_species = species.replace(novel_genus + ' ', parent_genus + ' ')
                    mask = self.assembly_metadata_df['species'] == species
                    self.assembly_metadata_df.loc[mask, 'species'] = new_species
                    self.stats_collapsed_assemblies += sum(mask)
        
        self.logger.info(f"Updated {self.stats_collapsed_assemblies} assembly entries to use parent genus")
        
        self.species_taxa_df.drop('genus', axis=1, inplace=True)

    def write_corrected_files(self):
        """
        Write the corrected dataframes to output files.
        """
        self.logger.info(f"Writing corrected assembly metadata to {self.output_assembly_metadata_file}")
        self.assembly_metadata_df.to_csv(self.output_assembly_metadata_file, index=False)
        
        self.logger.info(f"Writing corrected species taxa to {self.output_species_taxa_file}")
        self.species_taxa_df.to_csv(self.output_species_taxa_file, index=False)

    def gtdb_species_correction(self):
        """
        Execute the full correction process.
        """
        self.read_files()
        self.correct_species()
        if self.collapse_genera:
            self.collapse_novel_genera()
        self.write_corrected_files()